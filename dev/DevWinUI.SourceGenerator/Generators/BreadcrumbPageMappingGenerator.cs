using System.Collections.Immutable;
using System.Globalization;
using System.Text;
using System.Xml.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace DevWinUI;

[Generator]
internal sealed class BreadcrumbPageMappingGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Filter all project XAML files (skip obj/bin)
        var xamlFiles = context.AdditionalTextsProvider
            .Where(at =>
                at.Path.EndsWith(".xaml", StringComparison.OrdinalIgnoreCase) &&
                !at.Path.Contains($"{Path.DirectorySeparatorChar}obj{Path.DirectorySeparatorChar}") &&
                !at.Path.Contains($"{Path.DirectorySeparatorChar}bin{Path.DirectorySeparatorChar}")
            )
            .Collect(); // collect all XAML files into a single ImmutableArray

        var compilationProvider = context.CompilationProvider;

        // Combine XAML files + compilation
        var combined = xamlFiles.Combine(compilationProvider);

        context.RegisterSourceOutput(combined, (ctx, pair) =>
        {
            var (files, compilation) = pair;
            Execute(ctx, files, compilation); // single Execute for all files
        });
    }

    private static void Execute(SourceProductionContext ctx, ImmutableArray<AdditionalText> files, Compilation compilation)
    {
        var entries = new List<string>();

        foreach (var file in files)
        {
            string content;
            try
            {
                content = file.GetText(ctx.CancellationToken)?.ToString() ?? "";
            }
            catch { continue; }

            XDocument xamlDoc;
            try { xamlDoc = XDocument.Parse(content); }
            catch { continue; }

            var root = xamlDoc.Root;
            if (root == null) continue;

            // Skip non-page XAML
            if (root.Name.LocalName == "Window" || root.Name.LocalName == "Application" || root.Name.LocalName == "ResourceDictionary")
                continue;

            var xClassAttr = root.Attribute(XName.Get("Class", "http://schemas.microsoft.com/winfx/2006/xaml"));
            if (xClassAttr == null) continue;

            string pageType = xClassAttr.Value;
            string? pageTitle = GetAttachedProperty(root, "BreadcrumbNavigator.PageTitle");
            bool? isHeaderVisible = GetAttachedPropertyNullableBool(root, "BreadcrumbNavigator.IsHeaderVisible");
            bool? clearNavigation = GetAttachedPropertyNullableBool(root, "BreadcrumbNavigator.ClearCache");

            // If NONE of them exist → skip this page
            if (pageTitle is null && isHeaderVisible is null && clearNavigation is null)
                continue;

            // Apply defaults for missing values
            bool finalIsHeaderVisible = isHeaderVisible ?? false;
            bool finalClearNavigation = clearNavigation ?? false;

            entries.Add(
                $"{{ typeof({pageType}), new BreadcrumbPageConfig " +
                $"{{ PageTitle = {(pageTitle == null ? "null" : $"\"{pageTitle}\"")}, " +
                $"IsHeaderVisible = {finalIsHeaderVisible.ToString().ToLower()}, " +
                $"ClearNavigation = {finalClearNavigation.ToString().ToLower()} }} }}"
            );
        }

        if (entries.Count == 0) return;

        // Generate a single .g.cs file
        var sb = new StringBuilder();
        sb.AppendLine("// -----------------------------------------------------------------------------------------------------");
        sb.AppendLine("// | <auto-generated>                                                                                  |");
        sb.AppendLine("// |    This code was generated by source generator.                                                   |");
        sb.AppendLine("// |                                                                                                   |");
        sb.AppendLine("// |    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated. |");
        sb.AppendLine("// | </auto-generated>                                                                                 |");
        sb.AppendLine("// |                                                                                                   |");
        sb.AppendLine("// |                            -------------------------------------------                            |");
        sb.AppendLine("// |                            |                                         |                            |");
        sb.AppendLine($"// |                            | Date Modified: {DateTime.Now.ToString(CultureInfo.InvariantCulture)}  |                            |");
        sb.AppendLine("// |                            |                                         |                            |");
        sb.AppendLine("// |                            -------------------------------------------                            |");
        sb.AppendLine("// -----------------------------------------------------------------------------------------------------");
        sb.AppendLine();
        sb.AppendLine();
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        //sb.AppendLine("using AlAnvar;"); // BreadcrumbPageConfig namespace
        sb.AppendLine();
        var projectNamespace = compilation.AssemblyName ?? "GeneratedNamespace";
        sb.AppendLine($"namespace {projectNamespace};");
        sb.AppendLine("public partial class BreadcrumbPageMappings");
        sb.AppendLine("{");
        sb.AppendLine("    public static Dictionary<Type, BreadcrumbPageConfig> PageDictionary = new()");
        sb.AppendLine("    {");

        foreach (var e in entries)
            sb.AppendLine($"        {e},");

        sb.AppendLine("    };");
        sb.AppendLine("}");

        ctx.AddSource("BreadcrumbPageMappings.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static string? GetAttachedProperty(XElement element, string propertyName)
    {
        foreach (var attr in element.Attributes())
        {
            if (attr.Name.LocalName.EndsWith(propertyName))
                return attr.Value;
        }
        return null;
    }

    private static bool? GetAttachedPropertyNullableBool(XElement element, string propertyName)
    {
        var val = GetAttachedProperty(element, propertyName);
        if (string.IsNullOrEmpty(val)) return null;

        return val.Equals("True", StringComparison.OrdinalIgnoreCase);
    }

}
